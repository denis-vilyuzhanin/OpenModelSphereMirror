/*************************************************************************

Copyright (C) 2009 Grandite

This file is part of Open ModelSphere.

Open ModelSphere is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
or see http://www.gnu.org/licenses/.

You can redistribute and/or modify this particular file even under the
terms of the GNU Lesser General Public License (LGPL) as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

You should have received a copy of the GNU Lesser General Public License 
(LGPL) along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
or see http://www.gnu.org/licenses/.

You can reach Grandite at: 

20-1220 Lebourgneuf Blvd.
Quebec, QC
Canada  G2K 2G4

or

open-modelsphere@grandite.com

 **********************************************************************/

package org.modelsphere.jack.baseDb.db;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.TimeZone;

import javax.swing.Icon;

import org.modelsphere.jack.baseDb.db.event.DbRefreshListener;
import org.modelsphere.jack.baseDb.db.event.DbUpdateEvent;
import org.modelsphere.jack.baseDb.db.srtypes.DbtAbstract;
import org.modelsphere.jack.baseDb.db.srtypes.DbtLoginList;
import org.modelsphere.jack.baseDb.db.srtypes.SrInteger;
import org.modelsphere.jack.baseDb.db.srtypes.SrLong;
import org.modelsphere.jack.baseDb.db.srtypes.SrType;
import org.modelsphere.jack.baseDb.international.LocaleMgr;
import org.modelsphere.jack.baseDb.meta.MetaClass;
import org.modelsphere.jack.baseDb.meta.MetaField;
import org.modelsphere.jack.baseDb.meta.MetaRelation;
import org.modelsphere.jack.baseDb.meta.MetaRelation1;
import org.modelsphere.jack.baseDb.meta.MetaRelationN;
import org.modelsphere.jack.baseDb.meta.MetaRelationship;
import org.modelsphere.jack.baseDb.util.Sequencer;
import org.modelsphere.jack.debug.Debug;
import org.modelsphere.jack.text.MessageFormat;
import org.modelsphere.jack.util.ExceptionHandler;
import org.modelsphere.jack.util.SrVector;
import org.modelsphere.jack.util.StringUtil;

/**
 * The superclass of all the generated model classes. It defines generic accessors
 * <code>get()</code> and <code>set()</code>. Generic accessors require a MetaField parameter.
 * Specific accessors (<code>getXXX()</code> and <code>setXXX()</code> for a metafield named XXX)
 * support Java Beans naming conventions, and are generated by genmeta. <br>
 * <br>
 * The generic getter and specific getters invoke the <code>basicGet()</code> and then converts, if
 * applicable, the data from a SrType to the application type. Client code does not directly call
 * the <code>basicGet()</code> method. <br>
 * <br>
 * The generic setter and specific setters invoke one of the three basic methods:
 * <code>basicSet()</code>, <code>setRelationNN()</code> or <code>basicReinsert()</code>. Client
 * code does not directly call these methods. Specific setters may perform any required validations
 * or propagations, then calls <code>basicGet()</code>.
 * 
 */
public abstract class DbObject extends PersistentObject {

    static final long serialVersionUID = 8150047773762026780L;

    //values use for getSemanticalName and getSemanticalIcon
    public static final int SHORT_FORM = 1;
    public static final int LONG_FORM = 2;

    static HashMap matchingMap = null;

    protected static final byte ACCESS_GRANTED = 1; // 0 means uninitialized
    protected static final byte ACCESS_NOT_GRANTED = 2;
    protected transient byte writeAccess;
    transient Db db;
    transient DbProject project;
    transient int transStatus;
    /* Clone of the object containing the values at beginning of the transaction */
    private transient DbObject oldThis;
    private transient SrVector refreshListeners;

    // The object unique ID within the Db.  Not serialised.
    private transient String id = null;

    DbObject m_composite;
    DbRelationN m_components;
    DbRelationN m_udfValues;
    SrLong m_creationTime;
    SrLong m_modificationTime;
    transient SrInteger m_validationStatus;

    private transient String m_sequenceId = null;
    private transient Sequencer m_sequencer = Sequencer.getSingleton();

    // Validation Status
    public static final int VALIDATION_OK = 0;
    public static final int VALIDATION_WARNING = 1;
    public static final int VALIDATION_ERROR = 2;

    // Visibility Flags (factors of 2)
    public static final int HIDE_OFF = 0;
    public static final int HIDE_IN_EXPLORER = 1;
    public static final int HIDE_IN_DB_LIST = 2;
    private int m_hideFlags = HIDE_OFF; //default

    public void setHideFlags(int flag) {
        m_hideFlags = flag;
    }

    public int getHideFlags() {
        return m_hideFlags;
    }

    // Caution: this timestamp is not unique; may be used as a persistent hash code.
    // It is only accessible through the method getTs(); it has no metaField.
    int m_ts;

    public static final MetaRelation1 fComposite = new MetaRelation1(LocaleMgr.db
            .getString("composite"), 1);
    public static final MetaRelationN fComponents = new MetaRelationN(LocaleMgr.db
            .getString("components"), 0, MetaRelationN.cardN);
    public static final MetaRelationN fUdfValues = new MetaRelationN(LocaleMgr.db
            .getString("udfValues"), 0, MetaRelationN.cardN);
    public static final MetaField fCreationTime = new MetaField(LocaleMgr.db
            .getString("creationTime"));
    public static final MetaField fModificationTime = new MetaField(LocaleMgr.db
            .getString("modificationTime"));
    public static final MetaField fValidationStatus = new MetaField(LocaleMgr.db
            .getString("Status"));

    public final static MetaClass metaClass = new MetaClass("DbObject", DbObject.class, // NOT LOCALIZABLE class name
            new MetaField[] { fComposite, fComponents, fUdfValues, fCreationTime,
                    fModificationTime, fValidationStatus }, 0);

    public static void initMeta() {
        try {
            fComposite.setJField(DbObject.class.getDeclaredField("m_composite")); // NOT LOCALIZABLE field name
            fComposite.setVisibleInScreen(false);
            fComponents.setJField(DbObject.class.getDeclaredField("m_components")); // NOT LOCALIZABLE field name
            fComponents.setFlags(MetaField.WRITE_CHECK);
            fUdfValues.setJField(DbObject.class.getDeclaredField("m_udfValues")); // NOT LOCALIZABLE field name
            fUdfValues.setFlags(MetaField.WRITE_CHECK);

            //add creation and modification time
            //fCreationTime.setScreenOrder(">description"); // trick to have <creationTime> at the end of the screens  // NOT LOCALIZABLE
            fCreationTime.setJField(DbObject.class.getDeclaredField("m_creationTime")); // NOT LOCALIZABLE field name
            //fCreationTime.setEditable(false);
            fCreationTime.setVisibleInScreen(true);
            fCreationTime.setRendererPluginName("Timestamp");

            //fModificationTime.setScreenOrder(">description"); // trick to have <modificationTime> at the end of the screens  // NOT LOCALIZABLE
            fModificationTime.setJField(DbObject.class.getDeclaredField("m_modificationTime")); // NOT LOCALIZABLE field name
            //fModificationTime.setEditable(false);
            fModificationTime.setVisibleInScreen(true);
            fModificationTime.setRendererPluginName("Timestamp");

            fValidationStatus.setJField(DbObject.class.getDeclaredField("m_validationStatus"));
            fValidationStatus.setVisibleInScreen(false);

            fComposite.setOppositeRel(fComponents);
        } catch (Exception e) {
            throw new RuntimeException("Meta init"); // NOT LOCALIZABLE RuntimeException
        }
    }

    public static boolean valuesAreEqual(Object val1, Object val2) {
        if (val1 == val2)
            return true;
        if (val1 == null || val2 == null) {
            /* If String, consider that null and "" are equal. */
            Object val = (val1 == null ? val2 : val1);
            if (val instanceof String && ((String) val).length() == 0)
                return true;
            return false;
        }
        if (val1.getClass().isArray()) {
            Object[] array1 = (Object[]) val1;
            Object[] array2 = (Object[]) val2;
            if (array1.length != array2.length)
                return false;
            for (int i = 0; i < array1.length; i++) {
                if (!array1[i].equals(array2[i]))
                    return false;
            }
            return true;
        } else
            return val1.equals(val2);
    }

    public DbObject() {
    }

    public DbObject(DbObject composite) throws DbException {
        this(composite.db);
        project = (this instanceof DbProject ? (DbProject) this : composite.project);
        db.checkWriteTrans();
        setTransStatus(Db.OBJ_ADDED);
        setComposite(composite);
        Long currentTime = new Long(System.currentTimeMillis());
        basicSet(fCreationTime, currentTime);
        setModificationTime(currentTime);
    }

    DbObject(Db db) {
        this.db = db;
        this.transStatus = Db.OBJ_UNTOUCHED;
        this.m_ts = getNextTs();
    }

    private static int nbCreated = 0;

    public static int getNextTs() {
        nbCreated++;
        return (int) System.currentTimeMillis() + nbCreated;
    }

    public abstract MetaClass getMetaClass();

    //Override toString()
    //It is a good pratice to override toString() [Effective Java, Joshua Bloch, p42]
    @Override
    public String toString() {
        String s;
        try {
            MetaClass mc = getMetaClass();
            MetaField mf = mc.getMetaField("m_name");
            Object o = (mf == null) ? null : get(mf);
            s = (o == null) ? getFullDisplayName() : o.toString();
        } catch (DbException ex) {
            s = "???";
        }
        return s;
    }

    public String getFullDisplayName() throws DbException {
        String name = "";
        if (project != null) {
            name = (db instanceof DbRAM && project.getRamFileName() != null ? StringUtil
                    .getFileName(project.getRamFileName()) : project.getName());
            if (this == project)
                return name;
            name = name + ": "; //NOT LOCALIZABLE
        }
        name = name + getSemanticalName(LONG_FORM);
        return name;
    }

    public String getSemanticalName(int form) throws DbException {
        return (form == SHORT_FORM ? getName() : buildFullNameString());
    }

    public final String buildFullNameString() throws DbException {
        return buildFullNameString(null);
    }

    public final String buildFullNameString(ComponentIterator compIter) throws DbException {
        String fullName = getName();
        if (fullName == null)
            fullName = "";
        if (compIter != null)
            fullName = compIter.modifiedComponentName(this, fullName);
        if (!(this instanceof DbProject)) {
            DbObject parent = this;
            while (true) {
                parent = parent.getComposite();
                if (parent == null || parent instanceof DbRoot || parent instanceof DbProject
                        || (parent.getMetaClass().getFlags() & MetaClass.NAMING_ROOT) != 0)
                    break;
                String parentName = parent.getName();
                if (parentName == null)
                    parentName = "";
                if (compIter != null)
                    parentName = compIter.modifiedComponentName(parent, parentName);
                fullName = parentName + "." + fullName; //NOT LOCALIZABLE
            }
        }
        return fullName;
    }

    public static interface ComponentIterator {
        public String modifiedComponentName(DbObject component, String currentName)
                throws DbException;
    }

    public Icon getSemanticalIcon(int form) throws DbException {
        return getMetaClass().getIcon();
    }

    public int getMinCard(MetaRelationship metaRel) throws DbException {
        return metaRel.getMinCard();
    }

    // CAUTION: when this method is called, the object is not yet constructed;
    // the only information available is getMetaClass()
    public boolean isHugeRelN(MetaRelationN metaRelN) {
        return (metaRelN.getFlags() & MetaField.HUGE_RELN) != 0;
    }

    public final DbRelationN createRAMRelN(MetaRelationN metaRelN) {
        return (isHugeRelN(metaRelN) ? (DbRelationN) new DbHugeRAMRelationN()
                : (DbRelationN) new DbRAMRelationN());
    }

    /*
     * Create a new instance of <metaClass> and give it <this> as composite. Return null if
     * composite not allowed or if the construction of this class needs additionnal parameters.
     */
    public final DbObject createComponent(MetaClass metaClass) throws DbException {
        return createComponent(metaClass, null, null);
    }

    /*
     * Create a new instance of <metaClass> and give it <this> as composite. Return null if
     * composite not allowed or if the constructors don't match with the provided parameters. Do not
     * provide the composite object in parameters and paramClasses. Always considered as the first
     * parameter.
     */
    public final DbObject createComponent(MetaClass metaClass, Object[] parameters,
            Class[] parametersClasses) throws DbException {
        if (!metaClass.compositeIsAllowed(getMetaClass()))
            return null;
        try {
            if (parameters == null) {
                parameters = new Object[] {};
                parametersClasses = new Class[] {};
            }
            Object[] newParameters = new Object[parameters.length + 1];
            Class[] newParametersClasses = new Class[parameters.length + 1];
            newParametersClasses[0] = DbObject.class;
            newParameters[0] = this;
            System.arraycopy(parameters, 0, newParameters, 1, parameters.length);
            System.arraycopy(parametersClasses, 0, newParametersClasses, 1,
                    parametersClasses.length);
            Constructor constructor = metaClass.getJClass().getConstructor(newParametersClasses);
            return (DbObject) constructor.newInstance(newParameters);
        } catch (NoSuchMethodException e) {
        } catch (Exception e) {
            ExceptionHandler.throwRealException(e);
        }
        return null;
    }

    public final Db getDb() {
        return db;
    }

    public final DbProject getProject() {
        return project;
    }

    public final int getTs() throws DbException {
        db.checkTrans();
        db.fetch(this);
        return m_ts;
    }

    public final int getTransStatus() {
        return transStatus;
    }

    public final boolean isAddedAndRemoved() {
        return (transStatus == Db.OBJ_REMOVED && oldThis.m_composite == null);
    }

    public final boolean isAlive() throws DbException {
        db.checkTrans();
        db.fetch(this);
        return !(m_composite == null && transStatus == Db.OBJ_UNTOUCHED && this != db.getRoot());
    }

    // Works on a removed object
    public final DbObject getCompositeOfType(MetaClass metaClass) throws DbException {
        DbObject parent = this;
        while (true) {
            parent = (DbObject) parent.getAccordingToStatus(fComposite);
            if (parent == null || metaClass.getJClass().isInstance(parent))
                break;
        }
        return parent;
    }

    // Works on a removed object
    public final boolean isDescendingFrom(DbObject dbo) throws DbException {
        DbObject parent = this;
        while (parent != dbo) {
            parent = (DbObject) parent.getAccordingToStatus(fComposite);
            if (parent == null)
                return false;
        }
        return true;
    }

    // Returns the component of the specified class with the specified name;
    // metaClass may be null.
    public final DbObject findComponentByName(MetaClass metaClass, String name) throws DbException {
        boolean caseSensitive = true;
        DbObject dbo = findComponentByName(metaClass, name, caseSensitive);
        return dbo;
    }

    public final DbObject findComponentByName(MetaClass metaClass, String name,
            boolean caseSentitive) throws DbException {
        DbObject childFound = null;
        DbEnumeration dbEnum = getComponents().elements(metaClass);
        while (dbEnum.hasMoreElements()) {
            DbObject child = dbEnum.nextElement();
            String childName = child.getSemanticalName(SHORT_FORM);
            boolean sameName = caseSentitive ? name.equals(childName) : name
                    .equalsIgnoreCase(childName);

            if (sameName) {
                childFound = child;
                break;
            }
        }
        dbEnum.close();
        return childFound;
    }

    public String getName() throws DbException {
        MetaClass mc = getMetaClass();
        String guiname = (mc == null) ? "?" : mc.getGUIName();
        return guiname;
    }

    public void setName(String name) throws DbException {
    }

    public final String getId() throws DbException {
        if (id == null)
            id = new Long(getDb().nextId++).toString();
        return id;
    }

    // Called by the Delete Action
    public boolean isDeletable() throws DbException {
        return true;
    }

    // Called by the Delete Action
    public void doDeleteAction() throws DbException {
        remove();
    }

    public final boolean hasField(MetaField metaField) {
        return metaField.getMetaClass().getJClass().isInstance(this);
    }

    /*
     * Returns the value that the object has for this UDF; return null if the object has no value
     * for this UDF.
     * 
     * The UDF may be obtained from the static method: DbUDF udf = DbUDF.getUDF(project, metaClass,
     * udfName); Alternative: getUDF(udfName);
     */
    public final Object get(DbUDF udf) throws DbException {
        DbRelationN udfValues = getUdfValues();
        for (int i = 0; i < udfValues.size(); i++) {
            DbUDFValue udfValue = (DbUDFValue) udfValues.elementAt(i);
            if (udfValue.getComposite() == udf)
                return udfValue.getValue();
        }
        return null;
    }

    /*
     * Returns the value that the object has for this UDF; return null if the object has no value
     * for this UDF.
     */
    public final Object getUDF(String udfName) throws DbException {
        DbRelationN udfValues = getUdfValues();
        for (int i = 0; i < udfValues.size(); i++) {
            DbUDFValue udfValue = (DbUDFValue) udfValues.elementAt(i);
            if (((DbUDF) udfValue.getComposite()).getName().equals(udfName))
                return udfValue.getValue();
        }
        return null;
    }

    public final Object get(MetaField metaField) throws DbException {
        return toApplType(metaField, basicGet(metaField));
    }

    public final Object get(MetaField metaField, int which) throws DbException {
        return toApplType(metaField, basicGet(metaField, which));
    }

    public final Object getOld(MetaField metaField) throws DbException {
        return toApplType(metaField, basicGet(metaField, Db.OLD_VALUE));
    }

    public final Object getAccordingToStatus(MetaField metaField) throws DbException {
        return (transStatus == Db.OBJ_REMOVED ? getOld(metaField) : get(metaField));
    }

    public final boolean hasChanged(MetaField metaField) throws DbException {
        return !valuesAreEqual(basicGet(metaField), basicGet(metaField, Db.OLD_VALUE));
    }

    // For an uninitialized relation N, returns to the application an empty DbRAMRelationN.
    private final Object toApplType(MetaField metaField, Object obj) {
        if (obj == null) {
            if (!(metaField instanceof MetaRelationN))
                return null;
            DbRelationN dbRelN = new DbRAMRelationN();
            dbRelN.initTransientFields(this, (MetaRelationN) metaField);
            return dbRelN;
        }
        if (obj instanceof SrType)
            return ((SrType) obj).toApplType();
        return obj;
    }

    public final int getNbNeighbors(MetaRelationship relation) throws DbException {
        if (relation.getMaxCard() > 1) {
            DbRelationN dbRelN = (DbRelationN) basicGet(relation);
            return (dbRelN == null ? 0 : dbRelN.size());
        } else {
            DbObject dbo = (DbObject) basicGet(relation);
            return (dbo == null ? 0 : 1);
        }
    }

    /*
     * Must be defined in each subclass, to process the instance fields of the subclass; for fields
     * not known of the subclass, call super.set
     */
    public void set(MetaField metaField, Object value) throws DbException {
        if (metaField == fComposite)
            setComposite((DbObject) value);
        else if (metaField == fComponents)
            ((DbObject) value).setComposite(this);
        else if (metaField == fUdfValues)
            ((DbUDFValue) value).setDbObject(this);
        else if (metaField == fCreationTime)
            basicSet(fCreationTime, value);
        else if (metaField == fModificationTime)
            basicSet(fModificationTime, value);
        else if (metaField == fValidationStatus) {
            basicSet(fValidationStatus, value);
        } else
            throw new RuntimeException("Set method failed on " + metaField.toString()); // NOT LOCALIZABLE RuntimeException
    }

    /*
     * Must be defined in each subclass where N-N relations are defined, to process the N-N
     * relations of the subclass; for N-N relations not known of the subclass, call super.set
     */
    public void set(MetaRelationN relation, DbObject neighbor, int op) throws DbException {
        throw new RuntimeException("Set method failed on " + relation.toString()); // NOT LOCALIZABLE RuntimeException
    }

    public final void set(DbUDF udf, Object value) throws DbException {
        if (value != null) {
            if (value instanceof Boolean) {
                if (!((Boolean) value).booleanValue())
                    value = null;
            } else if (value instanceof String) {
                if (((String) value).length() == 0)
                    value = null;
            }
        }
        DbRelationN udfValues = getUdfValues();
        for (int i = 0; i < udfValues.size(); i++) {
            DbUDFValue udfValue = (DbUDFValue) udfValues.elementAt(i);
            if (udfValue.getComposite() == udf) {
                if (value == null)
                    udfValue.remove();
                else
                    udfValue.setValue(value);
                return;
            }
        }
        if (value != null) {
            new DbUDFValue(udf, this, value);
        }
    }

    public void reinsert(MetaRelationN relation, int oldIndex, int newIndex) throws DbException {
        basicReinsert(relation, oldIndex, newIndex);
    }

    /* Overriding methods must call super.remove() */
    public void remove() throws DbException {
        if (transStatus == Db.OBJ_REMOVED) /* to avoid infinite recursions */
            return;
        db.checkWriteTrans();
        setTransStatus(Db.OBJ_REMOVED);
        removeAux(fComposite); /*
                                * insure that refresh listeners are called for removal of this
                                * object first
                                */

        MetaField[] allMetaFields = getMetaClass().getAllMetaFields();
        for (int i = 0; i < allMetaFields.length; i++) {
            MetaField metaField = allMetaFields[i];
            if (metaField instanceof MetaRelationship)
                removeAux((MetaRelationship) metaField);
        }
    }

    /*
     * Set all relations to null. Propagate remove to children having a min card = 1.
     */
    private void removeAux(MetaRelationship relation) throws DbException {
        if (relation.getMaxCard() > 1) {
            /* Relation N, disconnect all children. */
            DbRelationN dbRelN = (DbRelationN) basicGet(relation);
            if (dbRelN == null)
                return;
            DbEnumeration dbEnum = dbRelN.elements();
            while (dbEnum.hasMoreElements()) {
                DbObject dbo = dbEnum.nextElement();
                MetaRelationship oppositeRel = relation.getOppositeRel(dbo);
                int oppMin = dbo.getMinCard(oppositeRel); // call getMinCard before unlinking
                if (oppositeRel.getMaxCard() > 1) {
                    setRelationNN((MetaRelationN) relation, dbo, Db.REMOVE_FROM_RELN);
                    if (dbo.getNbNeighbors(oppositeRel) < oppMin)
                        dbo.remove();
                } else {
                    dbo.basicSet(oppositeRel, null);
                    if (oppMin > 0)
                        dbo.remove();
                }
            }
            dbEnum.close();
            dbRelN.initTransientFields(null, null); /* breaks circular references for gc */
        } else { /* Relation 1, disconnect neighbor. */
            DbObject dbo = (DbObject) basicGet(relation);
            if (dbo == null)
                return;
            MetaRelationship oppositeRel = relation.getOppositeRel(dbo);
            int oppMin = dbo.getMinCard(oppositeRel); // call getMinCard before unlinking
            basicSet(relation, null);
            if (dbo.getNbNeighbors(oppositeRel) < oppMin)
                dbo.remove();
        }
    }

    /*
     * This is a dual database operation.
     * 
     * All source objects must have the same project, and a source object cannot be a descendant of
     * another source object; a source object cannot be the project itself.
     * 
     * BEWARE: the constructors and the setXXX methods are not called (except setComposite).
     * 
     * We proceed in 3 steps: create all the DbObjects without links (except on composite), link
     * them on all the relations, delete the DbObjects who have no value on mandatory relations.
     * 
     * We use the matchingObject facility.
     */
    public static DbObject[] deepCopy(DbObject[] dbos, DbObject composite,
            DeepCopyCustomizer customizer) throws DbException {
        DbObject[] newDbos = deepCopy(dbos, composite, customizer, false);
        return newDbos;
    }

    public static DbObject[] deepCopy(DbObject[] dbos, DbObject composite,
            DeepCopyCustomizer customizer, boolean namePrefixedWithCopyOf) throws DbException {
        if (composite instanceof DbRoot)
            throw new RuntimeException("Cannot copy the whole project"); // NOT LOCALIZABLE RuntimeException
        composite.db.checkWriteTrans();
        DbObject[] newDbos = new DbObject[dbos.length];
        if (dbos.length == 0)
            return newDbos;

        try {
            Db.beginMatching();
            DeepCopy deepCopy = new DeepCopy(dbos[0].project, composite.project, customizer);
            deepCopy.create(dbos, composite, namePrefixedWithCopyOf);
            deepCopy.fill();
            for (int i = 0; i < dbos.length; i++)
                newDbos[i] = dbos[i].getMatchingObject();
        } finally {
            Db.endMatching();
        }
        return newDbos;
    }

    /*
     * Save by serialization. Fetch all the objects of the graph before calling <writeObject>.
     * Disconnect the object from the root and convert all DbRelationN's to DbRAMRelationN's just
     * the time of the <writeObject>; do it without calling db.dirty(), to avoid write-locking
     * everything; the consequence is that we must restore the state of the objects ourselves,
     * because the DBMS is not aware of the objects modified.
     */
    public final void save(ObjectOutputStream out) throws DbException, IOException {
        if (db.getTransMode() != Db.TRANS_NONE)
            throw new RuntimeException("Save during a transaction"); // NOT LOCALIZABLE RuntimeException
        db.beginReadTrans();
        if (db.hasFetch())
            fetchGraph();
        DbObject oldComposite = m_composite;
        SrVector vecRelN = new SrVector(100);
        try {
            fieldSet(fComposite, null);
            DbRelationN dbRelN = db.createDbRelationN(this, fComponents);
            if (!(dbRelN instanceof DbRAMRelationN || dbRelN instanceof DbHugeRAMRelationN))
                toRAMGraph(vecRelN);
            out.writeObject(this);
        } finally {
            fieldSet(fComposite, oldComposite);
            int nb = vecRelN.size(); /* restore the DbRelationN's */
            for (int i = 0; i < nb; i++) {
                DbRelationN dbRelN = (DbRelationN) vecRelN.elementAt(i);
                dbRelN.getParent().fieldSet(dbRelN.getMetaRelation(), dbRelN);
            }
            db.abortTrans();
        }
    }

    /*
     * Load a serialized object (this = root under which to connect the object). Convert all
     * DbRAMRelationN's to DbRelationN's. Cluster all the objects of the loaded graph before commit.
     */
    public final DbObject load(ObjectInputStream in, VersionConverter converter)
            throws DbException, IOException, ClassNotFoundException {
        return load(in, converter, false);
    }

    public final DbObject load(ObjectInputStream in, VersionConverter converter, boolean isRestore)
            throws DbException, IOException, ClassNotFoundException {
        if (db.getTransMode() != Db.TRANS_NONE)
            throw new RuntimeException("Load during a transaction"); // NOT LOCALIZABLE RuntimeException
        DbObject dbo = (DbObject) in.readObject();
        db.beginWriteTrans("");
        db.setTransMode(Db.TRANS_LOAD); // no DbUpdateListeners and not undoable
        dbo.initTransientFields(this);
        DbRelationN dbRelN = db.createDbRelationN(dbo, fComponents);
        if (!(dbRelN instanceof DbRAMRelationN || dbRelN instanceof DbHugeRAMRelationN))
            dbo.toDbGraph();
        dbo.setTransStatus(Db.OBJ_ADDED);
        dbo.basicSet(fComposite, this);
        if (!isRestore) {
            db.setTransDescription(MessageFormat.format(LocaleMgr.db.getString("Load0"),
                    new Object[] { dbo.getName() }));
            dbo.resetAccessCtl();
            if (!(db instanceof DbRAM))
                dbo.basicSet(DbSemanticalObject.fAdminAccessList, new DbtLoginList(
                        new DbLogin[] { db.getLogin() }));
        }
        if (converter != null)
            dbo = converter.convertAfterLoad(dbo);
        dbo.clusterGraph();
        db.commitTrans();
        return dbo;
    }

    private void resetAccessCtl() throws DbException {
        if (this instanceof DbSemanticalObject) {
            basicSet(DbSemanticalObject.fWriteAccessList, null);
            basicSet(DbSemanticalObject.fAdminAccessList, null);
        }
        DbRelationN comps = (DbRelationN) basicGet(fComponents);
        if (comps != null) {
            for (int i = 0; i < comps.size(); i++)
                comps.elementAt(i).resetAccessCtl();
        }
    }

    /*
     * Enumerates all the descendants of this object on the composition link. If metaClass not null,
     * enumerates only the descendants that are instances of this metaClass.
     */
    public final DbEnumeration componentTree(MetaClass metaClass) throws DbException {
        return componentTree(metaClass, null, null);
    }

    public final DbEnumeration componentTree(MetaClass metaClass, MetaClass[] bounds)
            throws DbException {
        return componentTree(metaClass, null, bounds);
    }

    public final DbEnumeration componentTree(final MetaClass metaClass,
            boolean[] compositeAncestors, final MetaClass[] bounds) throws DbException {
        final boolean[] final_compositeAncestors = (compositeAncestors == null && metaClass != null) ? metaClass
                .markCompositePaths()
                : compositeAncestors;

        return new DbEnumeration() {

            private SrVector enumStack = null;
            private DbEnumeration dbEnum = null;
            private DbObject nextDbo = null;

            public boolean hasMoreElements() throws DbException {
                if (nextDbo != null)
                    return true;
                if (dbEnum == null) { // enumeration not initialized or already terminated
                    if (enumStack != null)
                        return false;
                    enumStack = new SrVector();
                    dbEnum = getComponents().elements();
                }
                loop: while (true) {
                    if (dbEnum.hasMoreElements()) {
                        DbObject dbo = dbEnum.nextElement();

                        if (bounds != null) {
                            MetaClass dboMetaClass = dbo.getMetaClass();
                            for (int i = 0; i < bounds.length; i++) {
                                if (bounds[i].isAssignableFrom(dboMetaClass)) {
                                    // For bounds metaclasses, add a boundary dbo to the enum if dbo instanceof metaClass
                                    if (metaClass == null || metaClass.getJClass().isInstance(dbo)) {
                                        nextDbo = dbo;
                                        return true;
                                    } else
                                        continue loop;
                                }
                            }
                        }
                        if (final_compositeAncestors == null
                                || final_compositeAncestors[dbo.getMetaClass().getSeqNo()]) {
                            DbRelationN components = dbo.getComponents();
                            if (components.size() != 0) {
                                enumStack.addElement(dbEnum);
                                dbEnum = components.elements();
                            }
                        }
                        if (metaClass == null || metaClass.getJClass().isInstance(dbo)) {
                            nextDbo = dbo;
                            return true;
                        }
                    } else {
                        dbEnum.close();
                        int last = enumStack.size() - 1;
                        if (last == -1) {
                            dbEnum = null;
                            return false;
                        }
                        dbEnum = (DbEnumeration) enumStack.elementAt(last);
                        enumStack.removeElementAt(last);
                    }
                }
            }

            public DbObject nextElement() throws DbException {
                if (nextDbo == null)
                    throw new RuntimeException("componentTree: nextElement without hasMoreElements"); // NOT LOCALIZABLE RuntimeException
                DbObject dbo = nextDbo;
                nextDbo = null;
                return dbo;
            }

            public void close() {
                if (dbEnum == null)
                    return;
                dbEnum.close();
                dbEnum = null;
                for (int nb = enumStack.size(); --nb >= 0;)
                    ((DbEnumeration) enumStack.elementAt(nb)).close();
            }
        };
    }

    public final DbObject getComposite() throws DbException {
        return (DbObject) get(fComposite);
    }

    public final void setComposite(DbObject value) throws DbException {
        MetaClass mc = value.getMetaClass();
        if (value == null || !getMetaClass().compositeIsAllowed(mc))
            throw new RuntimeException("Invalid composite"); // NOT LOCALIZABLE RuntimeException
        basicSet(fComposite, value);
    }

    public final Object getCreationTime() throws DbException {
        return (Object) get(fCreationTime);
    }

    public final String getEDCTimestamp() throws DbException {
        if (m_sequenceId == null) {
            Long modifTime = (Long) getCreationTime();
            String datetimeFormat = "yyyyMMddHHmmss";
            DateFormat dateFormat = DateFormat.getInstance();
            DateFormat df = new SimpleDateFormat(datetimeFormat);
            df.setTimeZone(TimeZone.getDefault());

            if (m_sequencer == null)
                m_sequencer = Sequencer.getSingleton();

            Integer seq = new Integer(m_sequencer.getSequenceId());
            String value = String.format("%1$5d", new Object[] { seq });
            value = value.replace(' ', '0');
            m_sequenceId = df.format(modifTime).concat(value);
        }
        return m_sequenceId;
    }

    public static final String generateEDCTimestamp() throws DbException {
        String sequenceId = null;
        Long modifTime = new Long(System.currentTimeMillis());
        String datetimeFormat = "yyyyMMddHHmmss";
        DateFormat dateFormat = DateFormat.getInstance();
        DateFormat df = new SimpleDateFormat(datetimeFormat);
        df.setTimeZone(TimeZone.getDefault());
        Integer seq = new Integer(Sequencer.getSingleton().getSequenceId());
        String value = String.format("%1$5d", new Object[] { seq });
        value = value.replace(' ', '0');
        sequenceId = df.format(modifTime).concat(value);
        return sequenceId;
    }

    public final Object getModificationTime() throws DbException {
        return (Object) get(fModificationTime);
    }

    public final void setModificationTime(Long value) throws DbException {
        basicSet(fModificationTime, value);
        DbObject dbObject = getComposite();
        if (dbObject != null)
            dbObject.setModificationTime(new Long(System.currentTimeMillis()));
    }

    public final int getValidationStatus() throws DbException {
        Integer value = (Integer) get(fValidationStatus);
        int status = (value == null) ? 0 : value;
        return status;
    }

    public final void setValidationStatus(int value) throws DbException {
        SrInteger i = new SrInteger(value);
        basicSet(fValidationStatus, i);
    }

    public final DbRelationN getComponents() throws DbException {
        return (DbRelationN) get(fComponents);
    }

    public final DbRelationN getUdfValues() throws DbException {
        return (DbRelationN) get(fUdfValues);
    }

    public boolean hasWriteAccess() throws DbException {
        if (writeAccess == 0) {
            if ((getMetaClass().getFlags() & MetaClass.ACCESS_CTL) != 0) {
                DbtLoginList loginList = ((DbSemanticalObject) this).getWriteAccessList();
                if (loginList != null)
                    writeAccess = (loginList.hasAccess(db) ? ACCESS_GRANTED : ACCESS_NOT_GRANTED);
            }
            if (writeAccess == 0) {
                DbObject composite = getComposite();
                writeAccess = (composite == null || composite.hasWriteAccess() ? ACCESS_GRANTED
                        : ACCESS_NOT_GRANTED);
            }
        }
        return (writeAccess == ACCESS_GRANTED);
    }

    public boolean hasAdminAccess() throws DbException {
        if ((getMetaClass().getFlags() & MetaClass.ACCESS_CTL) != 0) {
            DbtLoginList loginList = ((DbSemanticalObject) this).getAdminAccessList();
            if (loginList != null)
                return loginList.hasAccess(db);
        }
        DbObject composite = getComposite();
        return (composite == null || composite.hasAdminAccess());
    }

    final Object basicGet(MetaField metaField, int which) throws DbException {
        if (which == Db.NEW_VALUE)
            return basicGet(metaField);
        if (metaField instanceof MetaRelationN)
            throw new RuntimeException("getOld on " + metaField.toString()); // NOT LOCALIZABLE RuntimeException
        if (oldThis == null)
            return basicGet(metaField);

        db.checkTrans();
        return fetchValue(oldThis.fieldGet(metaField), metaField);
    }

    final Object basicGet(MetaField metaField) throws DbException {
        db.checkTrans();
        db.fetch(this); /* fetch the DbObject */

        /*
         * Throws a special condition if object deleted in a previous transaction (normally an
         * external transaction).
         */
        if (m_composite == null && transStatus == Db.OBJ_UNTOUCHED
                && db.getTransMode() == Db.TRANS_NORMAL && this != db.getRoot())
            throw new DbDeadObjectException(db, LocaleMgr.db.getString("DeadObject"));
        return fetchValue(fieldGet(metaField), metaField);
    }

    private final Object fetchValue(Object obj, MetaField metaField) throws DbException {
        if (obj == null)
            return obj;
        if (metaField instanceof MetaRelationship) {
            MetaRelationship metaRelation = (MetaRelationship) metaField;
            if (metaRelation.getMaxCard() > 1) {
                DbRelationN dbRelN = (DbRelationN) obj;
                dbRelN.initTransientFields(this, (MetaRelationN) metaRelation); /*
                                                                                 * set transient
                                                                                 * fields of the
                                                                                 * DbRelationN
                                                                                 */
                dbRelN.dbFetch(db); /* fetch the DbRelationN */
            } else
                /* set transient fields of the connected DbObject, but do not fetch it */
                ((DbObject) obj).initTransientFields(this);
        } else { /* fetch the value */
            if (obj instanceof SrType)
                ((SrType) obj).dbFetch(db);
            else if (obj.getClass().isArray()) {
                db.fetch(obj);
                if (obj instanceof SrType[]) {
                    /* If array of SrTypes, fetch each array element. */
                    SrType[] array = (SrType[]) obj;
                    for (int i = 0; i < array.length; i++)
                        array[i].dbFetch(db);
                }
            }
        }
        return obj;
    }

    /* Fetch the DbObject and all its fields. */
    private final void fetchAllValues() throws DbException {
        db.fetch(this);
        MetaField[] allMetaFields = getMetaClass().getAllMetaFields();
        for (int i = 0; i < allMetaFields.length; i++) {
            MetaField metaField = allMetaFields[i];
            fetchValue(fieldGet(metaField), metaField);
        }
    }

    /* Fetch the DbObject and all its descendants in the hierarchy <composite, components>. */
    private final void fetchGraph() throws DbException {
        fetchAllValues();
        if (m_components != null) {
            int nb = m_components.size();
            for (int i = 0; i < nb; i++)
                m_components.elementAt(i).fetchGraph();
        }
    }

    /*
     * Convert all DbRelationN's to DbRAMRelationN's in this DbObject and all its descendants in the
     * hierarchy <composite, components>. Keep all the DbRelationN's in a vector, to be able to
     * restore them after writeObject.
     */
    private final void toRAMGraph(SrVector vecRelN) throws DbException {
        MetaField[] allMetaFields = getMetaClass().getAllMetaFields();
        for (int i = 0; i < allMetaFields.length; i++) {
            MetaField metaField = allMetaFields[i];
            if (!(metaField instanceof MetaRelationN))
                continue;
            DbRelationN dbRelN = (DbRelationN) fieldGet(metaField);
            if (dbRelN == null)
                continue;
            vecRelN.addElement(dbRelN);
            DbRelationN dbRAMRelN = createRAMRelN((MetaRelationN) metaField);
            dbRAMRelN.initTransientFields(this, (MetaRelationN) metaField);
            int nb = dbRelN.size();
            for (int j = 0; j < nb; j++)
                dbRAMRelN.insertElementAt(dbRelN.elementAt(j), j);
            fieldSet(metaField, dbRAMRelN);
        }

        if (m_components != null) {
            int nb = m_components.size();
            for (int i = 0; i < nb; i++)
                m_components.elementAt(i).toRAMGraph(vecRelN);
        }
    }

    /*
     * Convert all DbRAMRelationN's to DbRelationN's in this DbObject and all its descendants in the
     * hierarchy <composite, components>.
     */
    private final void toDbGraph() throws DbException {
        MetaField[] allMetaFields = getMetaClass().getAllMetaFields();
        for (int i = 0; i < allMetaFields.length; i++) {
            MetaField metaField = allMetaFields[i];
            if (metaField instanceof MetaRelationN) {
                DbRelationN dbRAMRelN = (DbRelationN) fieldGet(metaField);
                if (dbRAMRelN != null) {
                    dbRAMRelN.initTransientFields(this, (MetaRelationN) metaField);
                    DbRelationN dbRelN = db.createDbRelationN(this, (MetaRelationN) metaField);
                    dbRelN.initTransientFields(this, (MetaRelationN) metaField);
                    int nb = dbRAMRelN.size();
                    for (int j = 0; j < nb; j++)
                        dbRelN.insertElementAt(dbRAMRelN.elementAt(j), j);
                    fieldSet(metaField, dbRelN);
                }
            }
        }

        if (m_components != null) {
            int nb = m_components.size();
            for (int i = 0; i < nb; i++)
                m_components.elementAt(i).toDbGraph();
        }
    }

    // Called by db.commitTrans() to cluster graphs of new objects.
    final void clusterGraph() throws DbException {
        if (getTransStatus() != Db.OBJ_ADDED)
            return;
        DbObject parent = (this instanceof DbUDFValue ? (DbObject) fieldGet(DbUDFValue.fDbObject)
                : m_composite);
        if (parent == null)
            return;

        if (parent.getTransStatus() == Db.OBJ_ADDED)
            return; // if parent added, will be clustered by clustering the graph of its parent.

        clusterOne();
        clusterChildren();
    }

    private void clusterChildren() throws DbException {
        if (this instanceof DbUDF || this instanceof DbUDFValue)
            return;
        if (m_components == null)
            return;
        int nb = m_components.size();
        int i;
        for (i = 0; i < nb; i++) {
            DbObject child = m_components.elementAt(i);
            if (child.getTransStatus() != Db.OBJ_ADDED && db.getTransMode() != Db.TRANS_LOAD)
                continue;
            if ((child.getMetaClass().getFlags() & MetaClass.CLUSTER_ROOT) == 0)
                child.clusterOne();
        }

        for (i = 0; i < nb; i++) {
            DbObject child = m_components.elementAt(i);
            if (child.getTransStatus() != Db.OBJ_ADDED && db.getTransMode() != Db.TRANS_LOAD)
                continue;
            if ((child.getMetaClass().getFlags() & MetaClass.CLUSTER_ROOT) != 0)
                child.clusterOne();
            child.clusterChildren();
        }
    }

    private void clusterOne() throws DbException {
        DbObject parent = null;
        if (this instanceof DbUDFValue)
            parent = (DbObject) fieldGet(DbUDFValue.fDbObject);
        else if ((getMetaClass().getFlags() & MetaClass.CLUSTER_ROOT) == 0)
            parent = m_composite;
        db.cluster(this, parent);

        MetaField[] allMetaFields = getMetaClass().getAllMetaFields();
        for (int i = 0; i < allMetaFields.length; i++) {
            MetaField metaField = allMetaFields[i];
            Object value = fieldGet(metaField);
            if (value instanceof DbRelationN) {
                ((DbRelationN) value).initTransientFields(this, (MetaRelationN) metaField);
                ((DbRelationN) value).dbCluster(db, this);
            } else if (value instanceof SrType)
                ((SrType) value).dbCluster(db, this);
        }

        if (m_udfValues != null) {
            int nb = m_udfValues.size();
            for (int i = 0; i < nb; i++)
                m_udfValues.elementAt(i).clusterOne();
        }
    }

    /*
     * Sequence of operations is critical: 1) all basicGet's and dirty's (may throw a DbException)
     * 2) db.set to record the update in the transaction 3) finally, modify the DbObjects.
     * 
     * <index> (applicable only if 1-N relation) = insertion index in the DbRelationN (-1 = insert
     * at the end).
     * 
     * Return false if actual value and new value is the same.
     */
    protected final boolean basicSet(MetaField metaField, Object value) throws DbException {
        return basicSet(metaField, value, -1);
    }

    protected final boolean basicSet(MetaField metaField, Object value, int index)
            throws DbException {
        //do nothing if object is not writable
        ReadOnly readOnly = ReadOnly.getSingleton();
        boolean isReadOnly = readOnly.isReadOnly(this, metaField, value);
        if (isReadOnly)
            return false;

        if (value != null) {
            if (value instanceof DbtAbstract)
                value = ((DbtAbstract) value).duplicate();
            else {
                Class type = metaField.getJField().getType();
                if (!(type.isPrimitive() || type.isInstance(value))) {
                    /* Convert an AWT type to a SrType; a SrType must have only one constructor. */
                    try {
                        Constructor[] constructors = type.getConstructors();
                        for (int i = 0; i < constructors.length; i++) {
                            Class[] parametersTypes = constructors[i].getParameterTypes();
                            if (parametersTypes.length == 0)
                                continue;
                            if (parametersTypes.length == 1) {
                                value = constructors[i].newInstance(new Object[] { value });
                                break;
                            }
                        }
                        if (!(value instanceof SrType))
                            throw new RuntimeException("Bad Meta - Invalid SrType:  " + type); // NOT LOCALIZABLE RuntimeException
                    } catch (Exception e) {
                        throw new RuntimeException("Set with a bad type argument"); // NOT LOCALIZABLE RuntimeException
                    }
                }
            }
        }

        Object oldValue = basicGet(metaField);
        if (valuesAreEqual(oldValue, value))
            return false;

        db.checkWriteTrans();
        if (metaField == fComposite
                && (db.getTransMode() == Db.TRANS_UNDO || db.getTransMode() == Db.TRANS_REDO)) {
            /* Modification of composite in Undo/Redo means an ADD or a DELETE */
            if (value == null)
                setTransStatus(Db.OBJ_REMOVED);
            else if (oldValue == null)
                setTransStatus(Db.OBJ_ADDED);
        }
        if (transStatus == Db.OBJ_REMOVED && value != null && db.getTransMode() == Db.TRANS_NORMAL)
            throw new RuntimeException("Set on a deleted object"); // NOT LOCALIZABLE RuntimeException

        checkWriteAccess(metaField);
        boolean isDeletedObject = false;
        if (metaField instanceof MetaRelationship) {
            DbObject oldDbo = (DbObject) oldValue;
            DbObject dbo = (DbObject) value;
            isDeletedObject = (dbo == null) ? true : (dbo.transStatus == Db.OBJ_REMOVED);

            if (dbo != null) {
                // TODO null project is an invalid state - should normally throw an exception (except for DbRoot)
                DbRoot root = db.getRoot();
                if (!dbo.equals(root)) {
                    if ((project == null && dbo.project == null))
                        Debug.trace("DbObject.basicSet():  The object is invalid (null project).");
                    //throw new RuntimeException("The object is invalid (null project).");  // NOT LOCALIZABLE RuntimeException
                } else if (project != null && project != dbo.project && dbo != db.getRoot()) {
                    throw new RuntimeException("Connect to an object of another project"); // NOT LOCALIZABLE RuntimeException
                } //end if

                if (isDeletedObject && db.getTransMode() == Db.TRANS_NORMAL)
                    throw new RuntimeException("Connect to a deleted object"); // NOT LOCALIZABLE RuntimeException
            } //end if

            MetaRelationship relation = (MetaRelationship) metaField;
            MetaRelationship oppositeRel = relation.getOppositeRel(oldDbo != null ? oldDbo : dbo);
            if (oldDbo != null)
                oldDbo.checkWriteAccess(oppositeRel);

            if (dbo != null)
                dbo.checkWriteAccess(oppositeRel);

            if (oppositeRel.getMaxCard() > 1)
                setRelation1N(relation, (MetaRelationN) oppositeRel, oldDbo, dbo, index);
            else
                setRelation11(relation, oppositeRel, oldDbo, dbo);
        } else {
            db.dirty(this);
            db.set(this, metaField, oldValue, value, -1, -1);
            setTransStatus(Db.OBJ_MODIFIED);
            fieldSet(metaField, value);
        } //end if

        if (!isDeletedObject) {
            int mode = db.getTransMode();
            if (mode != Db.TRANS_UNDO && mode != Db.TRANS_REDO)
                setModificationTime(new Long(System.currentTimeMillis()));
        }

        return true;
    }

    /*
     * Sequence of operations is critical.
     */
    private final void setRelation1N(MetaRelationship relation, MetaRelationN oppositeRel,
            DbObject oldDbo, DbObject dbo, int index) throws DbException {
        DbRelationN oldDbRelN = null;
        DbRelationN dbRelN = null;
        int oldIndex = -1;

        db.dirty(this);
        if (oldDbo != null) {
            oldDbRelN = oldDbo.getRelNForUpdate(oppositeRel);
            oldIndex = oldDbRelN.indexOf(this);
            oldDbRelN.dbDirty(db);
        }
        if (dbo != null) {
            dbRelN = dbo.getRelNForUpdate(oppositeRel);
            if (index == -1 || index > dbRelN.size()) /* may happen in Undo */
                index = dbRelN.size();
            dbRelN.dbDirty(db);
        }

        db.set(this, relation, oldDbo, dbo, oldIndex, index);

        setTransStatus(Db.OBJ_MODIFIED);
        fieldSet(relation, dbo);
        if (oldDbo != null) {
            oldDbo.setTransStatus(Db.OBJ_MODIFIED);
            oldDbRelN.removeElementAt(oldIndex);
        }
        if (dbo != null) {
            dbo.setTransStatus(Db.OBJ_MODIFIED);
            dbRelN.insertElementAt(this, index);
        }
    }

    private DbRelationN getRelNForUpdate(MetaRelationN metaRelN) throws DbException {
        DbRelationN dbRelN = (DbRelationN) basicGet(metaRelN);
        if (dbRelN == null) {
            dbRelN = db.createDbRelationN(this, metaRelN);
            dbRelN.initTransientFields(this, metaRelN);
            db.dirty(this);
            fieldSet(metaRelN, dbRelN);
        }
        return dbRelN;
    }

    /*
     * Sequence of operations is critical
     */
    private final void setRelation11(MetaRelationship relation, MetaRelationship oppositeRel,
            DbObject oldDbo, DbObject dbo) throws DbException {
        if (dbo != null && dbo.basicGet(oppositeRel) != null) {
            if (db.getTransMode() == Db.TRANS_UNDO || db.getTransMode() == Db.TRANS_REDO)
                db.throwDbUndoRedoConflictException(); /*
                                                        * another user changed the neighbor's
                                                        * relation.
                                                        */
            else
                throw new DbMaxConnectivityException(db, dbo.getName(), dbo.getMetaClass()
                        .getGUIName(false, false), oppositeRel.getGUIName(),
                        "Max. connectivity of " + oppositeRel.toString()); // NOT LOCALIZABLE
        }

        db.dirty(this);
        if (oldDbo != null)
            db.dirty(oldDbo);
        if (dbo != null)
            db.dirty(dbo);

        db.set(this, relation, oldDbo, dbo, -1, -1);

        setTransStatus(Db.OBJ_MODIFIED);
        fieldSet(relation, dbo);
        if (oldDbo != null) {
            oldDbo.setTransStatus(Db.OBJ_MODIFIED);
            oldDbo.fieldSet(oppositeRel, null);
        }
        if (dbo != null) {
            dbo.setTransStatus(Db.OBJ_MODIFIED);
            dbo.fieldSet(oppositeRel, this);
        }
    }

    /*
     * Sequence of operations is critical
     */
    protected final boolean setRelationNN(MetaRelationN relation, DbObject dbo, int op)
            throws DbException {
        return setRelationNN(relation, dbo, op, -1, -1);
    }

    protected final boolean setRelationNN(MetaRelationN relation, DbObject dbo, int op, int index,
            int oppositeIndex) throws DbException {
        db.checkWriteTrans();
        if (project != dbo.project)
            throw new RuntimeException("Connect to an object of another project"); // NOT LOCALIZABLE RuntimeException
        DbRelationN dbRelN = getRelNForUpdate(relation);
        MetaRelationN oppositeRel = (MetaRelationN) relation.getOppositeRel(dbo);
        DbRelationN oppositeDbRelN = dbo.getRelNForUpdate(oppositeRel);
        if (op == Db.ADD_TO_RELN) {
            if (dbRelN.indexOf(dbo) >= 0)
                return false;
            if (index == -1 || index > dbRelN.size()) /* may happen in Undo */
                index = dbRelN.size();
            if (oppositeIndex == -1 || oppositeIndex > oppositeDbRelN.size())
                oppositeIndex = oppositeDbRelN.size();
        } else {
            index = dbRelN.indexOf(dbo);
            if (index < 0)
                return false;
            oppositeIndex = oppositeDbRelN.indexOf(this);
        }

        checkWriteAccess(relation);
        dbo.checkWriteAccess(oppositeRel);

        dbRelN.dbDirty(db);
        oppositeDbRelN.dbDirty(db);

        db.setRelationNN(this, relation, dbo, op, index, oppositeIndex);

        setTransStatus(Db.OBJ_MODIFIED);
        dbo.setTransStatus(Db.OBJ_MODIFIED);
        if (op == Db.ADD_TO_RELN) {
            dbRelN.insertElementAt(dbo, index);
            oppositeDbRelN.insertElementAt(this, oppositeIndex);
        } else {
            dbRelN.removeElementAt(index);
            oppositeDbRelN.removeElementAt(oppositeIndex);
        }
        return true;
    }

    /*
     * Sequence of operations is critical.
     */
    protected final void basicReinsert(MetaRelationN relation, int oldIndex, int newIndex)
            throws DbException {
        db.checkWriteTrans();
        DbRelationN dbRelN = (DbRelationN) basicGet(relation);
        if (oldIndex == -1)
            oldIndex = dbRelN.size() - 1;
        if (newIndex == -1)
            newIndex = dbRelN.size() - 1;
        if (oldIndex == newIndex)
            return;

        checkWriteAccess(relation);
        DbObject dbo = dbRelN.elementAt(oldIndex);
        dbRelN.dbDirty(db);
        db.reinsert(dbRelN, dbo, oldIndex, newIndex);
        setTransStatus(Db.OBJ_MODIFIED);
        dbRelN.removeElementAt(oldIndex);
        dbRelN.insertElementAt(dbo, newIndex);
    }

    private void checkWriteAccess(MetaField field) throws DbException {
        if (db instanceof DbRAM || db.getTransMode() != Db.TRANS_NORMAL)
            return;
        if (transStatus == Db.OBJ_ADDED || isAddedAndRemoved())
            return;
        if (field instanceof MetaRelationN) {
            if ((field.getFlags() & MetaField.WRITE_CHECK) == 0)
                return;
            if (this instanceof DbUDF && field == fComponents)
                return;
        } else {
            if ((field.getFlags() & MetaField.NO_WRITE_CHECK) != 0)
                return;
        }
        if (!hasWriteAccess()) {
            DbObject dbo = (this instanceof DbUDFValue ? ((DbUDFValue) this).getDbObject() : this);
            String message = MessageFormat.format(LocaleMgr.db.getString("noWriteAccess"),
                    new Object[] { dbo.getMetaClass().getGUIName(),
                            dbo.getSemanticalName(LONG_FORM) });
            throw new DbException(db, message);
        }
    }

    // We assume here that every object is part of a project (except DbRoot) and
    // that there are no inter-project links.
    // So any pair of connected objects are necessarily in the same project.
    final void initTransientFields(DbObject neighbor) {
        if (db == null) {
            db = neighbor.db;
            if (this instanceof DbRoot)
                project = null;
            else if (this instanceof DbProject)
                project = (DbProject) this;
            else
                project = neighbor.project;
            transStatus = Db.OBJ_UNTOUCHED;
        }
    }

    // BEWARE: assume that db.fetch(this) or db.dirty(this) is already done
    final void setTransStatus(int transStatus) {
        if (this.transStatus == Db.OBJ_UNTOUCHED) {
            oldThis = duplicate_(null, true); /* clone the DbObject before modifying it */
            db.addModifiedObject(this); /* add to the list of modified objects in the transaction */
        } else if (transStatus == Db.OBJ_MODIFIED)
            return; /* status MODIFIED does not override status ADDED or DELETED */
        this.transStatus = transStatus;
    }

    final void resetTransStatus() {
        transStatus = Db.OBJ_UNTOUCHED;
        oldThis = null;
    }

    /*
     * Check 2 undetectable conflict cases in Undo/Redo: 1) Undoing a New: another user may have
     * added a child to a N-relation of the new DbObject. 2) Undoing a modif to an existing
     * DbObject: another user may have removed the DbObject.
     */
    final void checkUndoRedoConflicts() throws DbException {
        if (transStatus == Db.OBJ_REMOVED) {
            MetaField[] allMetaFields = getMetaClass().getAllMetaFields();
            for (int i = 0; i < allMetaFields.length; i++) {
                MetaField metaField = allMetaFields[i];
                if (metaField instanceof MetaRelationship
                        && getNbNeighbors((MetaRelationship) metaField) != 0)
                    db.throwDbUndoRedoConflictException();
            }
        } else {
            if (m_composite == null && this != db.getRoot())
                db.throwDbUndoRedoConflictException();
        }
    }

    // Use this method to clone an object
    final DbObject duplicate(MetaClass metaClass, boolean withRel) {
        try {
            DbObject dbo = duplicate_Impl(metaClass, withRel);
            return dbo;
        } catch (Exception e2) {
            throw new RuntimeException("Bad meta"); // NOT LOCALIZABLE RuntimeException
        }
    }

    // This method is used to backup objects before modifying these objects
    private DbObject duplicate_(MetaClass metaClass, boolean withRel) {
        try {
            return duplicate_Impl(metaClass, withRel);
        } catch (Exception e) {
            throw new RuntimeException("Bad meta"); // NOT LOCALIZABLE RuntimeException
        }
    }

    private DbObject duplicate_Impl(MetaClass metaClass, boolean withRel) throws Exception {
        MetaClass commonClass;
        if (metaClass == null)
            commonClass = metaClass = getMetaClass();
        else
            commonClass = getMetaClass().getCommonSuperMetaClass(metaClass);
        DbObject newDbo = (DbObject) metaClass.getJClass().newInstance();
        newDbo.db = db;
        newDbo.project = project;
        newDbo.m_ts = m_ts;
        newDbo.transStatus = Db.OBJ_UNTOUCHED;
        MetaField[] allMetaFields = commonClass.getAllMetaFields();
        for (int i = 0; i < allMetaFields.length; i++) {
            MetaField metaField = allMetaFields[i];
            Field jField = metaField.getJField();
            if (withRel || !(metaField instanceof MetaRelationship))
                jField.set(newDbo, jField.get(this));
        }
        return newDbo;
    }

    private final Object fieldGet(MetaField metaField) {
        try {
            return metaField.getJField().get(this);
        } catch (Exception e) {
            throw new RuntimeException("Bad meta"); // NOT LOCALIZABLE RuntimeException
        }
    }

    private final void fieldSet(MetaField metaField, Object value) {
        try {
            metaField.getJField().set(this, value);
        } catch (Exception e) {
            throw new RuntimeException("Bad meta"); // NOT LOCALIZABLE RuntimeException
        }
    }

    /*
     * <dbo> can be null, meaning <this> has no matching object; in this case, we can set a matching
     * object on <this> later. If an object is already matched, we cannot change directly its
     * matching; we must first undo its matching by doing setMatchingObject(null).
     * 
     * The mapping may return 3 possible values: <null> means the search for the matching object has
     * not been done yet; <dbRoot> means <this> has no matching object (search done, no object
     * found); any other value is the matching object (may be same as <this>).
     */
    public final void setMatchingObject(DbObject dbo) {
        if (matchingMap == null) {
            return;
        }

        DbObject match = (DbObject) matchingMap.get(this);
        if (match != null && match != db.getRoot()) {
            if (dbo == null) {
                matchingMap.put(this, db.getRoot());
                matchingMap.put(match, match.db.getRoot());
            } else if (dbo != match)
                throw new RuntimeException("Already matched"); // NOT LOCALIZABLE RuntimeException
        } else {
            if (dbo == null)
                matchingMap.put(this, db.getRoot());
            else if (dbo == this)
                matchingMap.put(this, this);
            else {
                match = (DbObject) matchingMap.get(dbo);
                if (match != null && match != dbo.db.getRoot())
                    throw new RuntimeException("Already matched"); // NOT LOCALIZABLE RuntimeException
                matchingMap.put(this, dbo);
                matchingMap.put(dbo, this);
            }
        }
    }

    public final DbObject getMatchingObject() {
        DbObject match = (DbObject) matchingMap.get(this);
        if (match != null) {
            if (match == db.getRoot() || match.transStatus == Db.OBJ_REMOVED)
                match = null;
        }
        return match;
    }

    /*
     * Search the matching object applying the method <matches> on all the children (of the class of
     * <this>) common to all the parents matched with the parents of <this>. If the parents of
     * <this> are not themselves already matched, apply the algorithm recursively on them.
     */
    public final DbObject findMatchingObject() throws DbException {
        DbObject match = (DbObject) matchingMap.get(this);
        if (match != null)
            return (match == db.getRoot() || match.transStatus == Db.OBJ_REMOVED ? null : match);

        DbObject matchDbo = null;
        MetaRelation1[] relations = getDependencyRelations();
        DbObject[] matchParents = new DbObject[relations.length];
        boolean sameParents = true;
        int i;
        for (i = 0; i < relations.length; i++) {
            DbObject parent = (DbObject) get(relations[i]);
            if (parent == null || parent == db.getRoot())
                break;
            matchParents[i] = parent.findMatchingObject();
            if (matchParents[i] == null)
                break;
            if (matchParents[i] != parent)
                sameParents = false;
        }
        if (i == relations.length) {
            if (sameParents)
                matchDbo = this;
            else if ((getMetaClass().getFlags() & MetaClass.MATCHABLE) != 0) {
                DbRelationN dbRelN = (DbRelationN) matchParents[0].get(relations[0]
                        .getOppositeRel(null));
                DbEnumeration dbEnum = dbRelN.elements();
                nextDbo: while (dbEnum.hasMoreElements()) {
                    DbObject dbo = dbEnum.nextElement();
                    if (dbo.getClass() != getClass())
                        continue;
                    for (i = 1; i < relations.length; i++) {
                        if (dbo.get(relations[i]) != matchParents[i])
                            continue nextDbo;
                    }
                    if (matches(dbo)) {
                        if (dbo.getMatchingObject() == null) // no matching for duplicates
                            matchDbo = dbo;
                        break;
                    }
                }
                dbEnum.close();
            }
        }
        setMatchingObject(matchDbo);
        return matchDbo;
    }

    /*
     * Must be overwritten by every class which has multiple dependencies. First relation should be
     * the one having less children (to optimize lookup).
     */
    private static MetaRelation1[] dependencyRelations = new MetaRelation1[] { fComposite };

    public MetaRelation1[] getDependencyRelations() {
        return dependencyRelations;
    }

    /*
     * Must be overwritten by every class whose objects may be matched by semantical id (the
     * metaClass must be marked MATCHABLE). The parents of <this> are already matched with the
     * parents of <dbo>; <this> and <dbo> are of the same class.
     */
    public boolean matches(DbObject dbo) throws DbException {
        return false;
    }

    /* refreshListeners vector currently in enumeration, and its current index. */
    private static SrVector refreshInEnum;
    private static int refreshIndex;

    public final void addDbRefreshListener(DbRefreshListener listener) {
        addDbRefreshListener(listener, DbRefreshListener.CALL_FOR_EVERY_FIELD);
    }

    public final void addDbRefreshListener(DbRefreshListener listener, int when) {
        if (refreshListeners == null)
            refreshListeners = new SrVector();
        DbRefreshListenerElement elem = new DbRefreshListenerElement(listener, when);
        int index = refreshListeners.indexOfUsingEquals(elem, 0);
        if (index == -1)
            refreshListeners.addElement(elem);
        else
            refreshListeners.setElementAt(elem, index);
    }

    public final void removeDbRefreshListener(DbRefreshListener listener) {
        if (refreshListeners == null)
            return;
        DbRefreshListenerElement elem = new DbRefreshListenerElement(listener, 0);
        int index = refreshListeners.indexOfUsingEquals(elem, 0);
        if (index != -1) {
            refreshListeners.removeElementAt(index);
            /* If remove from currently enumerated vector, correct the enumeration index */
            if (refreshInEnum == refreshListeners && refreshIndex > index)
                refreshIndex--;
        }
    }

    final boolean hasDbRefreshListeners() {
        return (refreshListeners != null && refreshListeners.size() != 0);
    }

    final void fireDbRefreshListeners(DbUpdateEvent event, int when) throws DbException {
        if (refreshListeners == null)
            return;
        refreshInEnum = refreshListeners;
        refreshIndex = refreshInEnum.size();
        while (--refreshIndex >= 0) {
            DbRefreshListenerElement elem = (DbRefreshListenerElement) refreshInEnum
                    .elementAt(refreshIndex);
            if (when == elem.when)
                elem.listener.refreshAfterDbUpdate(event);
        }
        refreshInEnum = null;
    }

    private static class DbRefreshListenerElement {

        final DbRefreshListener listener;
        final int when;

        DbRefreshListenerElement(DbRefreshListener listener, int when) {
            this.listener = listener;
            this.when = when;
        }

        public boolean equals(Object elem) {
            if (elem == null)
                return false;
            if (!(elem instanceof DbRefreshListenerElement))
                return false;
            return (listener == ((DbRefreshListenerElement) elem).listener);
        }
    }

    /**
     * Create a copy of DbObject
     */
    public DbObject copyComponent() throws DbException {
        DbObject parent = getComposite();
        MetaClass mc = getMetaClass();
        DbObject clone = parent.createComponent(mc);

        if (clone != null) {
            MetaField[] fields = getMetaClass().getAllMetaFields();
            for (MetaField mf : fields) {
                if (!(mf instanceof MetaRelation)) {
                    Object value = get(mf);
                    clone.set(mf, value);
                } else if (mf instanceof MetaRelation1) {
                    Object value = get(mf);
                    clone.set(mf, value);
                } else if (mf instanceof MetaRelationN) {
                    Object value = get(mf);
                    if (value instanceof DbRelationN) {
                        DbRelationN relN = (DbRelationN) value;
                        DbEnumeration enu = relN.elements();
                        while (enu.hasMoreElements()) {
                            DbObject srcComponent = enu.nextElement();
                            DbObject destComponent = srcComponent.copyComponent();
                            destComponent.setComposite(clone);
                        } //end while
                        enu.close();
                    } //end if
                } //end if
            } //end for
        } //end if

        return clone;
    } //end copyComponent()

}
